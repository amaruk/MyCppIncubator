#pragma once
class OverloadCast
{
public:
    OverloadCast();
    ~OverloadCast();

    /*
        重载的运算符是函数，其名字由关键字operator和其后要定义的运算符号组成，
        其参数与该运算符作用的运算对象数量一样多。

        对一个运算符函数来说，要么是类的成员，要么至少函授一个类类型的参数，
        为了防止内置类型的运算符被重载：int operator+(int, int);

        只能重载已有的运算符，不能创造运算符。

        可以重载的运算符：
            +       -       *       /       &       ^
            &       |       ~       !       ,       =
            <       >       <=      >=      ++      --
            <<      >>      ==      !=      &&      ||
            +=      -+      /=      %=      ^=      &=
            |=      *=      <<=     >>=     []      ()
            ->      ->*     new     new[]   delete  delete[]
        不可以重载的运算符：
            ::      .*      .       ?:
        不建议重载的运算符：
            逻辑与/或，逗号运算符重载后，运算对象求值顺序无法保留
            &&和||重载后无法保留短路求值属性，两个运算对象总是被求值
            逗号和取地址运算符对类类型对象有特殊含义，重载后导致用户无法适应
        必须是成员函数的重载：
            =       []      ()      ->
            复合赋值运算符（如+=）一般是成员，但非必须
            递增/递减/解引用运算符改变对象状态或与给定类型密切相关，通常是成员
            具有对称性的运算符可能转换任意一段的运算对象，如算术/相等性/关系/位运算符，通常是非成员函数

        调用的两种方式：
        data1 + data2
        operator+(data1, data2)

        如果是成员运算符函数，调用方式如下：
        data1 += data2
        data1.operator+=(data2)

        区别成员运算符函数和非成员运算符函数：
        string s = "world";
        string u - "hi" + s;    // 如果+被string重载为成员函数，则错误，相当于"hi".operator+(s)，而“hi“是const char *，内置类型没有成员
                                // 实际上，+被string重载为非成员函数，两个运算对象至少有一个是string类类型时，相当于operator+("hi",s)，两个实参都可转换为形参类型。
        string t = s + "!";     // 正确，同上

        
    */ 
    page 494 14.2.1 重载输出运算符<<

};

